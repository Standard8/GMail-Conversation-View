<!DOCTYPE html [
  <!ENTITY % pageDTD SYSTEM "chrome://conversations/locale/pages.dtd"> %pageDTD;
]>
<html xmlns="http://www.w3.org/1999/xhtml"
  xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
<head>
  <title>Conversation Reader</title>
  <link rel="stylesheet" type="text/css"
    href="chrome://messenger/skin/tagColors.css"/>
  <link rel="stylesheet" type="text/css"
    href="chrome://conversations/skin/boxflex.css" />
  <!-- Keep the order! -->
  <link rel="stylesheet" type="text/css"
    href="chrome://conversations/skin/conversation.css" />
  <link rel="stylesheet" type="text/css"
    href="chrome://conversations/skin/quickreply.css" />
  <link rel="stylesheet" type="text/css"
    href="chrome://conversations/skin/tokeninput.css" />
  <link rel="stylesheet" type="text/css" media="print"
    href="chrome://conversations/skin/print.css" />
  <script type="text/javascript"
    src="chrome://conversations/content/vendor/react.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/vendor/react-dom.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/vendor/redux.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/vendor/react-redux.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/vendor/reactjs-popup.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/vendor/prop-types.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/reducer.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/attachments.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/conversationHeader.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/conversationFooter.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/messageIFrame.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/message.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/messageActionButton.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/messageHeaderOptions.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/messageHeader.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/messageDetails.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/messageNotification.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/messageFooter.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/contactDetail.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/messageAttachments.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/messageList.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/quoting.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/messageTags.js"></script>
  <script type="text/javascript"
    src="chrome://conversations/content/conversationWrapper.js"></script>
  <!-- The two scripts below share the same scope, they were split for the sake
    of readability. -->
  <!-- <script type="application/javascript"
    src="chrome://conversations/content/quickReply.js"></script>
  <script type="application/javascript"
    src="chrome://conversations/content/stub.completion-ui.js"></script>
  <script type="application/javascript"
    src="chrome://conversations/content/stub.compose-ui.js"></script> -->
  <script type="application/javascript"><![CDATA[
    /* import-globals-from quickReply.js */
    /* import-globals-from reducer.js */
    /* global $, registerQuickReply, newComposeSessionByDraftIf
              Redux, ReactDOM, React, ReactRedux, ConversationWrapper,
              gComposeSession:true, tmpl, createComposeSession, revealCompositionFields,
              editFields, asToken, setupAutocomplete, Gloda, Log:true,
              setupLogging, dumpCallStack */
    let store;
    var {StringBundle} = ChromeUtils.import("resource:///modules/StringBundle.js");
    /* exported Services */
    var {Services} = ChromeUtils.import("resource://gre/modules/Services.jsm");
    var strings = new StringBundle("chrome://conversations/locale/message.properties");

    /* exported conversationDispatch */
    function conversationDispatch(...args) {
      store.dispatch(...args);
    }

    document.addEventListener("focus", function(event) {
      /* This is a persistent event listener. It can operate multiple
       * times. We have the invariant that for a given conversation, there's at
       * most one such element (recycling doesn't use tabindex 1). */
      let msgNode = document.querySelector(".message[tabindex=\"1\"]");
      if (!msgNode)
        return;

      /* Restore the proper tab order. This event is fired *after* the
       * right message has been focused in Gecko 1.9.2, *before* the right
       * message has been focused in Gecko 1.9.1 (so it's basically
       * useless). */
      let msgNodes = document.getElementsByClassName("message");
      let index = Array.prototype.indexOf.call(msgNodes, msgNode);
      if (index != -1) {
        msgNode.setAttribute("tabindex", index + 2);
      }
    }, true);

    // Below are event listeners for various actions. There is some logic
    //  involved, and they may talk to other parts of the code.

    // This property is now set from the outside. This allows stub.html to
    //  be used either in a standalone tab or in the multimessage pane.
    // let Conversations = window.top.Conversations;

    var {MailServices} = ChromeUtils.import("resource:///modules/MailServices.jsm");
    const {isOSX, isWindows, parseMimeLine} =
      ChromeUtils.import("resource://conversations/modules/stdlib/misc.js");
    const {msgUriToMsgHdr, msgHdrsMarkAsRead} =
      ChromeUtils.import("resource://conversations/modules/stdlib/msgHdrUtils.js");
    const {Prefs} = ChromeUtils.import("resource://conversations/modules/prefs.js");
    const {topMail3Pane} = ChromeUtils.import("resource://conversations/modules/misc.js");
    const {defaultPhotoURI} = ChromeUtils.import("resource://conversations/modules/contact.js");
    const {
      setupLogging, dumpCallStack,
    } = ChromeUtils.import("resource://conversations/modules/log.js");

    Log = setupLogging("Conversations.Stub");
    // Declare with var, not let, so that it's in the global scope, not the lexical scope.
    /* exported isInTab */
    var isInTab = false;

    document.addEventListener("DOMContentLoaded", () => {
      let html = document.body.parentNode;
      if (Prefs.tweak_chrome) {
        if (isWindows) {
          html.setAttribute("os", "windows");
        } else if (isOSX) {
          html.setAttribute("os", "osx");
        } else {
          html.setAttribute("os", "linux");
        }
      } else {
        html.removeAttribute("os");
      }
    }, {once: true});

    let oldPrint = window.print;

    function printConversation(event) {
      for (let { message: m } of Conversations.currentConversation.messages) {
        m.dumpPlainTextForPrinting();
      }
      oldPrint();
    }

    window.print = printConversation;

    document.addEventListener("DOMContentLoaded", () => {
      store = Redux.createStore(conversationApp);

      const conversationContainer = document.getElementById("conversationWrapper");
      ReactDOM.render(React.createElement(ReactRedux.Provider, {store},
        React.createElement(ConversationWrapper)), conversationContainer);
    }, {once: true});

    /**
     * That big event handler tries to parse URL query parameters, and then acts
     * upon these, by firing a conversation on its own. This is a very
     * stripped-down version of the logic that's in monkeypatch.js, and it
     * serves the purpose of being able to create a standalone conversation view
     * in a new tab.
     */
    document.addEventListener("DOMContentLoaded", () => {
      const params = (new URL(document.location)).searchParams;

      // Oh, are we expected to build a conversation on our own? Let's do it,
      // yay!
      if (params.has("urls")) {
        try {
          let scrollMode = (params.get("scrollMode"))
            ? parseInt(params.scrollMode)
            : Prefs.kScrollUnreadOrLast;
          /* If we start up Thunderbird with a saved conversation tab, then we
           * have no selected message. Fallback to the usual mode. */
          if (scrollMode == Prefs.kScrollSelected &&
              !topMail3Pane(window).gFolderDisplay.selectedMessage)
            scrollMode = Prefs.kScrollUnreadOrLast;

          isInTab = true;
          if (window.frameElement)
            window.frameElement.setAttribute("tooltip", "aHTMLTooltip");
          let mainWindow = topMail3Pane(window);
          // let willExpand = parseInt(params.get("willExpand"));
          let msgHdrs = params.get("urls").split(",").map(x => msgUriToMsgHdr(x))
                              .filter(x => x != null && x.messageId);
          // It might happen that there are no messages left...
          if (!msgHdrs.length) {
            document.getElementById("messageList").textContent =
              strings.get("messageMovedOrDeletedConversation");
          } else {
            window.Conversations = {
              currentConversation: null,
              counter: 0,
            };
            let freshConversation = new mainWindow.Conversations.monkeyPatch._Conversation(
              window,
              msgHdrs,
              scrollMode,
              ++Conversations.counter
            );
            let browser = window.frameElement;
            // Because Thunderbird still hasn't fixed that...
            if (browser) {
              browser.setAttribute("context", "mailContext");
            }

            freshConversation.outputInto(window, function(aConversation) {
              // This is a stripped-down version of what's in monkeypatch.js,
              //  make sure the two are in sync!
              Conversations.currentConversation = aConversation;
              aConversation.completed = true;
              // TODO: Re-enable this.
              // registerQuickReply();
              // That's why we saved it before...
              newComposeSessionByDraftIf();
              // TODO: expandQuickReply isn't defined anywhere. Should it be?
              // if (willExpand)
              //   expandQuickReply();
              // Create a new rule that will override the default rule, so that
              // the expanded quick reply is twice higher.
              document.body.classList.add("inTab");
              // Do this now so as to not defeat the whole expand/collapse
              // logic.
              if (Prefs.getBool("mailnews.mark_message_read.auto")) {
                setTimeout(function() {
                  msgHdrsMarkAsRead(msgHdrs, true);
                }, Prefs.getInt("mailnews.mark_message_read.delay.interval")
                   * Prefs.getBool("mailnews.mark_message_read.delay") * 1000);
              }
            });
          }
        } catch (e) {
          Log.debug(e);
          dumpCallStack(e);
        }
      } else if (params.get("quickCompose")) {
        masqueradeAsQuickCompose();
      }
    }, {once: true});

    /* exported isQuickCompose */
    var isQuickCompose = false;

    /* This is our new hack: reuse this file to provide a standalone composition
     * window. Why? Because it uses gloda autocomplete and provides a
     * no-frills composition experience. */
    function masqueradeAsQuickCompose() {
      isQuickCompose = true;
      document.title = strings.get("write");
      document.querySelector("#conversationHeader").style.display = "none";
      document.querySelector(".bottom-links").style.display = "none";
      document.querySelector("#messageList").style.marginTop = "0";
      document.querySelector("#messageList").classList.add("quickCompose");
      tmpl("#quickReplyTemplate").appendTo($("#messageList"));
      $(".replyAll, #save, .replyMethod").remove();

      // TODO figure out why this timeout is needed
      setTimeout(function() {
        showQuickReply.call($(".reply.expand"));
        gComposeSession = createComposeSession(x => x.new());
        revealCompositionFields();
        editFields("to");
      }, 0);

      window.Conversations = {
        currentConversation: {
          msgHdrs: [],
          id: null,
        },
      };

      document.querySelector(".quickReply").addEventListener("keypress", function(event) {
        switch (event.keyCode) {
          case KeyEvent.DOM_VK_RETURN:
            if (isAccel(event)) {
              if (event.shiftKey)
                gComposeSession.send({ archive: true });
              else
                gComposeSession.send();
            }
            break;
        }
      });


      let data = [];

      // Push a new contact item in the list
      let pushNewPopularContacts = function(n) {
        let items = data.splice(0, n);
        let nodes = tmpl("#popularContactTemplate", items);

        items.forEach(function(data2, i) {
          let data = data2;
          let node = nodes.eq(i);
          Log.debug("Adding", data.name, data.email);

          node.find(".popularRemove").click(function() {
            Log.debug("Removing", data.name, data.email);
            // Mark it in the prefs
            let unwantedRecipients = JSON.parse(Prefs.getString("conversations.unwanted_recipients"));
            unwantedRecipients[data.email] = null;
            Prefs.setString("conversations.unwanted_recipients",
              JSON.stringify(unwantedRecipients));
            // Update the UI
            $(this).closest(".popularContact").remove();
            pushNewPopularContacts(1);
          });

          node.find(".popularName").click(function() {
            // Get all the current parameters
            let to = JSON.parse($("#to").val());
            let cc = JSON.parse($("#cc").val());
            let bcc = JSON.parse($("#bcc").val());
            // Append our new value
            to.push(MailServices.headerParser.makeMimeAddress(data.name, data.email));
            // Re-set everything
            let format = items => items.map(parseMimeLine)
                                       .map(([{ name, email }]) => asToken(null, name, email, null));
            setupAutocomplete(format(to), format(cc), format(bcc));
            // Remove the node!
            node.remove();
            pushNewPopularContacts(1);
          });
        });

        nodes.appendTo($(".quickReplyContactsBox"));
      };

      $(".quickReplyContactsMoreLink").click(() => pushNewPopularContacts(10));

      // Fill in the "10 most popular contacts" thing
      let contactQuery = Gloda.newQuery(Gloda.NOUN_CONTACT);
      contactQuery.orderBy("-popularity").limit(100);
      let contactCollection = contactQuery.getCollection({
        onItemsAdded(aItems, aCollection) {
    },
        onItemsModified(aItems, aCollection) {
    },
        onItemsRemoved(aItems, aCollection) {
    },
        onQueryCompleted(aCollection) {
      let items = aCollection.items;
      let unwantedRecipients = JSON.parse(Prefs.getString("conversations.unwanted_recipients"));

      for (let contact of items) {
        if (contact.identities.length) {
          let id = contact.identities[0];
          let photoForAbCard = function(card) {
            if (!card)
              return defaultPhotoURI;
            let url = card.getProperty("PhotoURI", "");
            if (!url)
              return defaultPhotoURI;
            return url;
          };
          if (id.kind == "email" && !(id.value in unwantedRecipients)) {
            // Log.debug("Pushing", id.value, contact.name, contact.popularity);
            data.push({
              email: id.value,
              name: contact.name,
              photo: photoForAbCard(id.abCard),
            });
          }
        }
      }

      pushNewPopularContacts(10);
    },
      }, null);
      contactCollection.becomeExplicit();

      // Misc
      if (!top.opener) {
        window.frameElement.setAttribute("tooltip", "aHTMLTooltip");
        window.frameElement.setAttribute("context", "mailContext");
      }
    }

    // Mark a message as read if a user scrolls past top and bottom of an
    // unread message.
    function markReadInView(event) {
      if (event.type == "keydown") {
        // for scroll by keyboard shortcut
        switch (event.which) {
          case KeyEvent.DOM_VK_SPACE:
          case KeyEvent.DOM_VK_TAB:
          case KeyEvent.DOM_VK_PAGE_UP:
          case KeyEvent.DOM_VK_PAGE_DOWN:
          case KeyEvent.DOM_VK_UP:
          case KeyEvent.DOM_VK_DOWN:
          case KeyEvent.DOM_VK_F:
          case KeyEvent.DOM_VK_B:
            break;
          default:
            return;
        }
      }
      document.removeEventListener("scroll", markReadInView, true);
      clearTimeout(markReadInView.timeout);
      markReadInView.timeout = setTimeout(function() {
        document.addEventListener("scroll", markReadInView, true);
      }, 200);
      if (!Conversations.currentConversation)
        return;

      let pageTop = window.pageYOffset;
      let pageBottom = pageTop + window.innerHeight;
      let messages = Conversations.currentConversation.messages;
      messages.forEach(function({ message }, i) {
        if (!message.read && message.expanded) {
          if (!message._topInView) {
            let top = $(message._domNode).offset().top;
            if (top > pageTop && top < pageBottom)
              message._topInView = true;
          }
          if (!message._bottomInView) {
            let footerClass = (i == messages.length - 1) ? ".quickReply" : ".messageFooter";
            let bottom = $(message._domNode.querySelector(footerClass)).offset().top;
            if (bottom > pageTop && bottom < pageBottom)
              message._bottomInView = true;
          }
          if (message._topInView && message._bottomInView) {
            message._topInView = false;
            message._bottomInView = false;
            message.read = true;
          }
        }
      });
    }
    (function() {
      let w = window;
      markReadInView.enable = function() {
        for (let x of ["mouseover", "focus", "keydown"]) {
          w.document.addEventListener(x, w.markReadInView, true);
        }
      };
      markReadInView.disable = function() {
        w.clearTimeout(w.markReadInView.timeout);
        for (let x of ["mouseover", "focus", "keydown", "scroll"]) {
          w.document.removeEventListener(x, w.markReadInView, true);
        }
      };
    })();

    // Lightning
    /* exported ltnImipBar */
    var ltnImipBar = topMail3Pane(window).ltnImipBar;
]]>
  </script>
</head>

<body>
  <script id="messageTemplate" type="text/x-handlebars-template"><![CDATA[
    <li class="message collapsed {{extraClasses}}">
      <!-- The following goes after the messageDetails -->

      {{#if generateLightningTempl}}
      <div class="lightningImipBar notificationBar" style="display: none">
        <img class="lightningImipImage" src="chrome://calendar/skin/cal-icon32.png"/>
        <span class="lightningImipText"></span>
        <!-- The text for all these buttons is filled dynamically -->

        <!-- show event/invitation details -->
        <button id="imipDetailsButton"
                class="lightningImipButton msgHeaderView-button imipDetailsButton"
                onclick="ltnImipBar.executeAction('X-SHOWDETAILS')"
                style="display: none">
        </button>

        <!-- add published events -->
        <button id="imipAddButton"
                class="lightningImipButton msgHeaderView-button imipAddButton"
                onclick="ltnImipBar.executeAction()"
                style="display: none">
        </button>

        <!-- update published events and invitations -->
        <button id="imipUpdateButton"
                class="lightningImipButton msgHeaderView-button imipUpdateButton"
                onclick="ltnImipBar.executeAction()"
                style="display: none">
        </button>

        <!-- delete cancelled events from calendar -->
        <button id="imipDeleteButton"
                class="lightningImipButton msgHeaderView-button imipDeleteButton"
                onclick="ltnImipBar.executeAction()"
                style="display: none">
        </button>

        <!-- re-confirm partstat -->
        <button id="imipReconfirmButton"
                class="lightningImipButton msgHeaderView-button imipReconfirmButton"
                onclick="ltnImipBar.executeAction()"
                style="display: none">
        </button>

        <!-- accept -->
        <button id="imipAcceptButton"
                onclick="if (event.target.id == this.id) ltnImipBar.executeAction('ACCEPTED');"
                type="menu-button"
                class="imip-button lightningImipButton msgHeaderView-button imipAcceptButton"
                style="display: none">
          <menupopup id="imipAcceptDropdown">
            <menuitem id="imipAcceptButton_Accept"
                      onclick="ltnImipBar.executeAction('ACCEPTED');"/>
            <menuitem id="imipAcceptButton_Tentative"
                      onclick="ltnImipBar.executeAction('TENTATIVE');"/>
            <!-- add here more menuitem as needed -->
          </menupopup>
        </button>

        <!-- accept recurrences -->
        <button id="imipAcceptRecurrencesButton"
                onclick="if (event.target.id == this.id) ltnImipBar.executeAction('ACCEPTED');"
                type="menu-button"
                class="imip-button lightningImipButton msgHeaderView-button imipAcceptRecurrencesButton"
                style="display: none">
          <menupopup id="imipAcceptRecurrencesDropdown">
            <menuitem id="imipAcceptRecurrencesButton_Accept"
                      onclick="ltnImipBar.executeAction('ACCEPTED');"/>
            <menuitem id="imipAcceptRecurrencesButton_Tentative"
                      onclick="ltnImipBar.executeAction('TENTATIVE');"/>
            <!-- add here more menuitem as needed -->
          </menupopup>
        </button>

        <!-- tentative; should only be used, if no imipMoreButton is used and
           - imipDeclineButton/imipAcceptButton have no visible menuitems //-->
        <button id="imipTentativeButton"
                class="lightningImipButton msgHeaderView-button imipTentativeButton"
                onclick="if (event.target.id == this.id) ltnImipBar.executeAction('TENTATIVE');"
                type="menu-button"
                style="display: none">
          <menupopup id="imipTentativeDropdown">
            <menuitem id="imipTentativeButton_Tentative"
                      onclick="ltnImipBar.executeAction('TENTATIVE');"/>
            <!-- add here more menuitem as needed -->
          </menupopup>
        </button>

        <!-- tentative recurrences; should only be used, if no imipMoreButton is used and
           - imipDeclineRecurrencesButton/imipAcceptRecurrencesButton have no visible menuitems //-->
        <button id="imipTentativeRecurrencesButton"
                class="lightningImipButton msgHeaderView-button imipTentativeRecurrencesButton"
                onclick="if (event.target.id == this.id) ltnImipBar.executeAction('TENTATIVE');"
                type="menu-button"
                style="display: none">
          <menupopup id="imipTentativeRecurrencesDropdown">
            <menuitem id="imipTentativeRecurrencesButton_Tentative"
                      onclick="ltnImipBar.executeAction('TENTATIVE');"/>
            <!-- add here more menuitem as needed -->
          </menupopup>
        </button>

        <!-- decline -->
        <button id="imipDeclineButton"
                onclick="if (event.target.id == this.id) ltnImipBar.executeAction('DECLINED');"
                type="menu-button"
                class="lightningImipButton msgHeaderView-button imipDeclineButton"
                style="display: none">
          <menupopup id="imipDeclineDropdown">
            <menuitem id="imipDeclineButton_Decline"
                      onclick="ltnImipBar.executeAction('DECLINED');"/>
            <!-- add here more menuitem as needed -->
          </menupopup>
        </button>

        <!-- decline recurrences -->
        <button id="imipDeclineRecurrencesButton"
                onclick="if (event.target.id == this.id) ltnImipBar.executeAction('DECLINED');"
                type="menu-button"
                class="lightningImipButton msgHeaderView-button imipDeclineRecurrencesButton"
                style="display: none">
          <menupopup id="imipDeclineRecurrencesDropdown">
            <menuitem id="imipDeclineRecurrencesButton_DeclineAll"
                      onclick="ltnImipBar.executeAction('DECLINED');"/>
            <!-- add here more menuitem as needed -->
          </menupopup>
        </button>

        <!-- more options -->
        <button id="imipMoreButton"
                type="menu"
                class="lightningImipButton msgHeaderView-button imipMoreButton"
                style="display: none">
          <menupopup id="imipMoreDropdown">
            <!-- add here a menuitem as needed -->
          </menupopup>
        </button>
      </div>
      {{/if}}
      <div class="phishingBar notificationBar" style="display: none">
        <svg class="icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><use xlink:href="chrome://conversations/skin/material-icons.svg#warning"></use></svg>
        {{str "scam"}}
        <span class="ignore-warning">
          <a href="javascript:">{{str "ignoreWarning"}}</a>
        </span>
      </div>
      <!-- Remote Content / Junk / Outbox bars went here */
      <div class="enigmailBar notificationBar" style="display: none">
        <span class="enigmailMessage"></span>
        <span class="enigmailDetails">
          <button>{{str "Details"}}</button>
        </span>
      </div>
    </li>
    ]]>
  </script>
  <div id="conversationWrapper">
  </div>
</body>
</html>
